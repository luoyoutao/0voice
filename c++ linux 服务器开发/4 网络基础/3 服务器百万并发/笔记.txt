1、epoll水平触发/边沿触发

对于recv：
水平触发：
内核缓冲区非空，有数据可以读取，就一直触发
边沿触发：
对方发送一次数据，buffer里来数据了触发一次，即buffer中增加数据时触发一次，
没有读完的数据，就只有等下次对方再发数据到buffer时再次触发继续读。

对于send：
水平触发：
内核写缓冲区不满，有空间可以写入，就一直触发
边沿触发：
？？？？？？？？？？

2、水平触发 与 边沿触发 应用场景
小数据 边沿触发
数据多的 水平触发
listenfd 用水平触发（因为用边沿触发可能会漏掉一些客户端的请求）

大小数据的分界点，取决于你自己设置的buffer的size，
如果能一次性读完，就鉴定为小数据，如果一次性不能读完，就
定为大数据。比如你设置的buffer size为1024，而对方传送的文件
是100MB，大于1024字节，定为大数据。

3、百万连接的并发
五元组：
目的IP、目的端口、源IP、源端口、TCP
使用三个虚拟机作为客户端
由于端口最多65535，约等于6万
3 * 6万 = 18万 < 100万
因此，服务端多开些端口，开100个

除此，通过ulimit -a查看一个进程最多能开的fd，为1024。
为了能多开些，我们要更改一下。
通过root用户，
vi /etc/security/limits.conf
在文件末尾添加如下：
*	hard	nofile	1048576
*	soft	nofile	1048576

1048576 = 1024 * 1024

另外设置协议栈
root用户下
vi /etc/sysctl.conf 

# 设置协议栈TCP连接的大小
net.ipv4.tcp_mem = 262144 524288 786432

# send的大小
net.ipv4.tcp_wmem = 512 512 1024

# recv的大小
net.ipv4.tcp_rmem = 512 512 1024

4、多线程、多进程 reactor

1.100个listenfd分别放到不同的线程
2.监听一个端口8888，开进程
3.listenfd与clientfd，分别放在不同线程

